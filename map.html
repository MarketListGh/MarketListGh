<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Accra Market Navigator ‚Äî Light Road Map</title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

  <style>
    :root {
  --accent: #00a859;
  --bg: #f7f7f7;
  --blue:#1976d2;
  --red:#d32f2f;
}

html, body, #map {
  height: 100%;
  margin: 0;
  padding: 0;
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial;
}

#map {
  width: 100%;
  height: 100vh;
  background: var(--bg);
  min-height: 400px; /* ensures map is not too small on very small screens */
}

/* top controls */
.topbar {
  position: absolute;
  left: 12px;
  right: 12px;
  top: 12px;
  z-index: 1400;
  display: flex;
  gap: 8px;
  flex-wrap: wrap; /* allows items to move to new line on smaller screens */
  align-items: center;
}

.search-box {
  display: flex;
  gap: 8px;
  align-items: center;
  background: #fff;
  padding: 8px;
  border-radius: 10px;
  box-shadow: 0 6px 22px rgba(0,0,0,0.09);
  position: relative;
  flex: 1 1 200px; /* allows box to grow/shrink */
  max-width: 100%; /* never overflow */
}

.search-box input {
  border: 0;
  outline: 0;
  font-size: 14px;
  padding: 6px 8px;
  width: 100%; /* takes all available space in box */
  border-radius: 6px;
}

.btn {
  padding: 8px 12px;
  border-radius: 8px;
  border: 0;
  cursor: pointer;
  background: var(--accent);
  color: #fff;
  font-weight: 600;
  display: inline-flex;
  align-items: center;
  gap: 8px;
  position: relative;
  flex-shrink: 0; /* buttons don‚Äôt shrink too much */
}

.btn.secondary { background: #1976d2; }
.btn:disabled { opacity: 0.6; cursor: not-allowed; }

/* spinner (iOS-style smooth) */
.spinner {
  width: 16px;
  height: 16px;
  border-radius: 50%;
  border: 2px solid rgba(255,255,255,0.35);
  border-top-color: white;
  animation: spin 0.7s linear infinite;
  display: none;
}
.btn.loading .spinner { display: inline-block; }
@keyframes spin { to { transform: rotate(360deg); } }

/* suggestions dropdown */
.suggestions {
  position: absolute;
  top: 44px;
  left: 0;
  width: 100%;
  max-height: 260px;
  overflow: auto;
  background: #fff;
  box-shadow: 0 8px 30px rgba(0,0,0,0.12);
  border-radius: 8px;
  display: none;
  z-index: 1500;
  padding: 6px;
}

/* responsive suggestions row */
.suggestion-row {
  display: flex;
  gap: 8px;
  padding: 8px;
  cursor: pointer;
  border-radius: 6px;
  align-items: flex-start;
}
.suggestion-row:hover { background:#f7fff7; }
.suggestion-icon { width:36px; font-size:20px; line-height:1; margin-top:2px; text-align:center; }
.suggestion-main { font-weight:700; font-size:14px; color:#111; }
.suggestion-sub { font-size:12px; color:#666; margin-top:4px; }

/* legend/status */
.status {
  position: absolute;
  left: 12px;
  bottom: 12px;
  background: rgba(255,255,255,0.95);
  padding: 8px 12px;
  border-radius: 10px;
  box-shadow: 0 10px 30px rgba(0,0,0,0.08);
  z-index: 1400;
  font-size: 13px;
}

/* small popup nav button */
.popup-nav {
  margin-top: 8px;
  display: flex;
  gap: 8px;
  align-items: center;
}
.nav-btn, .zoom-btn {
  padding: 6px 10px;
  border-radius: 8px;
  cursor: pointer;
  border: 0;
  font-weight: 600;
  display: inline-flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
}
.nav-btn { background:#1976d2; color:#fff; }
.zoom-btn { background:#00a859; color:#fff; }

/* icons legend */
.legend {
  position: absolute;
  right: 12px;
  bottom: 12px;
  z-index: 1400;
  background: rgba(255,255,255,0.95);
  padding: 8px 12px;
  border-radius: 10px;
  box-shadow: 0 10px 30px rgba(0,0,0,0.08);
  font-size: 13px;
}
.legend .item { display: flex; gap: 6px; align-items: center; margin-bottom: 6px; }
.emoji { font-size: 18px; line-height: 1; display: inline-block; width: 22px; text-align: center; }

/* responsive adjustments */
@media (max-width: 700px){
  .topbar { left:8px; right:8px; top:8px; gap:6px; }
  .search-box { flex: 1 1 100%; } /* full width on mobile */
  .search-box input { font-size: 13px; padding: 5px; }
  .btn { font-size: 13px; padding: 6px 10px; }
}
 </style>
</head>
<body>

  <div class="topbar">
    <div class="search-box" id="placeSearchWrap" style="position:relative;">
      <input id="placeSearch" placeholder="Search markets / malls (e.g., Makola, Accra Mall)" autocomplete="off">
      <div id="placeSug" class="suggestions" aria-hidden="true"></div>
      <button class="btn secondary" id="findPlacesBtn" title="Load nearby places">
        <span class="spinner" aria-hidden="true"></span>
        Load Nearby Places
      </button>
    </div>

    <div class="search-box" id="userSearchWrap" style="position:relative;">
      <input id="userSearch" placeholder="Search your location (e.g., Mamobi or paste plus code)" autocomplete="off">
      <div id="userSug" class="suggestions" aria-hidden="true"></div>
      <button class="btn" id="locateBtn" title="Detect my location">
        <span class="spinner" aria-hidden="true"></span>
        Detect Me
      </button>
    </div>

    <button class="btn" id="clearRouteBtn" title="Clear route">
      Clear Route
    </button>
  </div>

  <div id="map" role="application" aria-label="Map container"></div>

  <div class="status" id="status">Loading map ‚Äî centering on Accra...</div>

  <div class="legend" aria-hidden="true">
    <div class="item"><span class="emoji">üìç</span> <strong>User (you - blue)</strong></div>
    <div class="item"><span class="emoji">üìç</span> <strong>Market/Mall (red)</strong></div>
    <div class="item"><span class="emoji">üß∫</span> Market</div>
    <div class="item"><span class="emoji">üõçÔ∏è</span> Mall</div>
    <div class="item"><span class="emoji">üõí</span> Supermarket / Store</div>
  </div>
    <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script>
  (function(){
    // ---------------- CONFIG ----------------
    const API_KEY_GEOAPIFY = '0bf67747adfd4bb9bfab74ec373372fb'; // your Geoapify key
    const ACCRA = [5.6037, -0.1870];
    const INITIAL_ZOOM = 13;
    const PLACE_FETCH_RADIUS = 15000; // meters (15 km)
    const MAX_PLACES = 200; // safety cap
    const PLACES_VISIBLE_ZOOM = 14; // show loaded places only when zoom >= this
    const AUTOCOMPLETE_LIMIT = 6;

    // ----------------- MAP INIT -----------------
    const map = L.map('map', {preferCanvas:true, zoomControl:true}).setView(ACCRA, INITIAL_ZOOM);

    // Light street / white road style: CartoDB Positron (free)
    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
      maxZoom: 20,
      attribution: '&copy; OpenStreetMap contributors &copy; CARTO'
    }).addTo(map);

    // ----------------- ICONS -----------------
    function createSvgPin(color, size = 36) {
      const svg = encodeURIComponent(`
        <svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 24 24">
          <defs>
            <filter id="s" x="-50%" y="-50%" width="200%" height="200%">
              <feDropShadow dx="0" dy="2" stdDeviation="2" flood-opacity="0.25" flood-color="#000"/>
            </filter>
          </defs>
          <path fill="${color}" stroke="#fff" stroke-width="1.2" filter="url(#s)"
            d="M12 2C8.14 2 5 5.14 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.86-3.14-7-7-7z"/>
          <circle cx="12" cy="9" r="3" fill="#fff" />
        </svg>`);
      const html = `<div style="width:${size}px;height:${size}px;transform: translateY(-6px);"><img src="data:image/svg+xml;utf8,${svg}" style="width:100%;height:100%"/></div>`;
      return L.divIcon({ html, className: '', iconSize:[size,size], iconAnchor:[Math.round(size/2), size - 6] });
    }

    const userIcon = createSvgPin('#1976d2', 36); // blue pin
    const marketRedIcon = createSvgPin('#d32f2f', 34); // red pin

    function createPinEmojiIcon(emoji, size=22){
      const html = `<div style="display:flex;align-items:center;justify-content:center;width:${size}px;height:${size}px;border-radius:50%;font-size:${Math.round(size*0.8)}px">${emoji}</div>`;
      return L.divIcon({ html, className:'', iconSize:[size,size], iconAnchor:[Math.round(size/2), size - 6] });
    }
    const marketEmojiIcon = createPinEmojiIcon('üß∫', 22);
    const mallEmojiIcon = createPinEmojiIcon('üõçÔ∏è', 22);
    const shopEmojiIcon = createPinEmojiIcon('üõí', 22);

    // ----------------- GLOBAL STATE (exposed to window for Save button) -----------------
    window._ml_state = {
      userLatLng: { lat: ACCRA[0], lng: ACCRA[1] },
      currentRouteTarget: null,
      userMarker: null,
      dropMarketMarker: null,
      routeLayer: null
    };

    // user marker
    let userLatLng = { lat: ACCRA[0], lng: ACCRA[1] };
    let userMarker = L.marker([userLatLng.lat, userLatLng.lng], { icon: userIcon, draggable:true }).addTo(map).bindPopup('Your location (drag to adjust)');
    window._ml_state.userMarker = userMarker;
        userMarker.on('dragend', (e) => {
      const p = e.target.getLatLng();
      userLatLng = { lat: +p.lat, lng: +p.lng };
      window._ml_state.userLatLng = userLatLng;
      updateStatus(`User pin moved to ${userLatLng.lat.toFixed(5)}, ${userLatLng.lng.toFixed(5)}`);
      if (window._ml_state.currentRouteTarget) drawRouteTo(window._ml_state.currentRouteTarget);
      const userInput = document.getElementById('userSearch');
      if(userInput) userInput.style.boxShadow = "0 0 0 3px rgba(25,118,210,0.12)";
    });

    // places layer group
    const placesLayer = L.layerGroup().addTo(map);

    // route, markers
    // mirrored in window._ml_state when set

    // status updater
    const statusEl = document.getElementById('status');
    function updateStatus(text){ statusEl.textContent = text; }

    // ----------------- OVERPASS (unchanged) -----------------
    function overpassQuery(centerLat, centerLon, radius){
      return `
        [out:json][timeout:25];
        (
          node["amenity"="marketplace"](around:${radius},${centerLat},${centerLon});
          way["amenity"="marketplace"](around:${radius},${centerLat},${centerLon});
          node["shop"="supermarket"](around:${radius},${centerLat},${centerLon});
          way["shop"="supermarket"](around:${radius},${centerLat},${centerLon});
          node["shop"="mall"](around:${radius},${centerLat},${centerLon});
          way["shop"="mall"](around:${radius},${centerLat},${centerLon});
          node["shop"="department_store"](around:${radius},${centerLat},${centerLon});
          way["shop"="department_store"](around:${radius},${centerLat},${centerLon});
          node["shop"="convenience"](around:${radius},${centerLat},${centerLon});
          way["shop"="convenience"](around:${radius},${centerLat},${centerLon});
        );
        out center ${MAX_PLACES};
      `;
    }

    const loadedPlaceMarkers = [];

    async function fetchPlacesAndShow(){
      setButtonLoading(document.getElementById('findPlacesBtn'), true);
      updateStatus('Fetching nearby markets & malls (OSM)...');
      placesLayer.clearLayers();
      loadedPlaceMarkers.length = 0;
      window._ml_state.currentRouteTarget = null;
      if(window._ml_state.routeLayer){ try{ map.removeLayer(window._ml_state.routeLayer); }catch(e){} window._ml_state.routeLayer = null; }
      if(window._ml_state.dropMarketMarker){ try{ map.removeLayer(window._ml_state.dropMarketMarker); }catch(e){} window._ml_state.dropMarketMarker = null; }

      try{
        const q = overpassQuery(ACCRA[0], ACCRA[1], PLACE_FETCH_RADIUS);
        const resp = await fetch('https://overpass-api.de/api/interpreter', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8' },
          body: 'data=' + encodeURIComponent(q)
        });
        if(!resp.ok) throw new Error('Overpass fetch failed: ' + resp.status);
        const data = await resp.json();
        if(!data.elements || !data.elements.length){
          updateStatus('No nearby places found.');
          setButtonLoading(document.getElementById('findPlacesBtn'), false);
          return;
        }

        let count = 0;
        for(const el of data.elements){
          if(count >= MAX_PLACES) break;
          let lat = el.lat, lon = el.lon;
          if(!lat && el.center){ lat = el.center.lat; lon = el.center.lon; }
          if(!lat || !lon) continue;

          const tags = el.tags || {};
          let placeType = 'market';
          if (tags.shop === 'supermarket' || tags.shop === 'department_store' || tags.shop === 'convenience') placeType = 'supermarket';
          if (tags.shop === 'mall') placeType = 'mall';
          if (tags.amenity === 'marketplace') placeType = 'market';

          let icon = marketEmojiIcon;
          if(placeType === 'mall') icon = mallEmojiIcon;
          if(placeType === 'supermarket') icon = shopEmojiIcon;

          const title = tags.name || tags['name:en'] || (placeType === 'market' ? 'Market' : placeType === 'mall' ? 'Mall' : 'Store');

          const marker = L.marker([lat, lon], { icon, title }).on('click', () => {
            const distKm = haversineKm(window._ml_state.userLatLng.lat, window._ml_state.userLatLng.lng, lat, lon);
            const popupHtml = `
              <div style="min-width:200px;">
                <strong>${escapeHtml(title)}</strong><br>
                <small>${placeType.toUpperCase()}</small>
                <div style="margin-top:6px;">Distance: <strong id="popupDistance">${distKm.toFixed(2)} km</strong></div>
                <div class="popup-nav">
                  <button class="nav-btn" id="navHereBtn">Navigate Here</button>
                  <button class="zoom-btn" id="zoomHereBtn">Zoom</button>
                </div>
              </div>`;
            marker.bindPopup(popupHtml).openPopup();

            setTimeout(() => {
              const navBtn = document.getElementById('navHereBtn');
              const zoomBtn = document.getElementById('zoomHereBtn');
              if(navBtn) navBtn.addEventListener('click', () => {
                setElementLoading(navBtn, true);
                const target = { lat: lat, lng: lon, title };
                window._ml_state.currentRouteTarget = target;
                dropRedMarketPin(lat, lon, title);
                drawRouteTo(target, navBtn).finally(()=> setElementLoading(navBtn, false));
              });
              if(zoomBtn) zoomBtn.addEventListener('click', () => {
                map.setView([lat, lon], 17, { animate:true });
              });
            }, 120);
          });

          loadedPlaceMarkers.push({ marker, lat, lon, title, placeType });
          count++;
        }

        refreshPlaceVisibility();

        updateStatus(`Loaded ${loadedPlaceMarkers.length} places (markers will show when zoomed in).`);
      } catch(err){
        console.error(err);
        updateStatus('Failed to load places (Overpass). Try again later.');
      } finally {
        setButtonLoading(document.getElementById('findPlacesBtn'), false);
      }
    }

    document.getElementById('findPlacesBtn').addEventListener('click', fetchPlacesAndShow);

    function refreshPlaceVisibility(){
      if(map.getZoom() >= PLACES_VISIBLE_ZOOM){
        loadedPlaceMarkers.forEach(p => {
          if(!placesLayer.hasLayer(p.marker)) placesLayer.addLayer(p.marker);
        });
      } else {
        loadedPlaceMarkers.forEach(p => {
          if(placesLayer.hasLayer(p.marker)) placesLayer.removeLayer(p.marker);
        });
      }
    }
    map.on('zoomend', refreshPlaceVisibility);
        // ----------------- GEOAPIFY AUTOCOMPLETE (detailed + emoji) -----------------
    async function geoapifyAutocomplete(query, limit=AUTOCOMPLETE_LIMIT){
      if(!query || !query.trim()) return [];
      // Bias to current map center for relevance
      const center = map.getCenter();
      try {
        const resp = await fetch(`https://api.geoapify.com/v1/geocode/autocomplete?text=${encodeURIComponent(query)}&limit=${limit}&bias=proximity:${center.lat},${center.lng}&apiKey=${API_KEY_GEOAPIFY}`);
        if(!resp.ok) return [];
        const j = await resp.json();
        if(!j.features) return [];
        return j.features.map(f => f);
      } catch(e){
        console.warn('Geoapify autocomplete failed', e);
        return [];
      }
    }

    function classifyGeoapifyFeature(feat){
      const p = feat.properties || {};
      const name = (p.formatted || '').toLowerCase();
      const categories = (p.categories || '').toLowerCase();
      if(categories.includes('mall') || name.includes('mall') || (p.type && String(p.type).toLowerCase().includes('mall'))) return { icon:'üõçÔ∏è', kind:'mall' };
      if(categories.includes('market') || name.includes('market') || (p.type && String(p.type).toLowerCase().includes('market'))) return { icon:'üß∫', kind:'market' };
      if(categories.includes('supermarket') || name.includes('supermarket') || name.includes('super mart') || name.includes('maxmart') || name.includes('shop')) return { icon:'üõí', kind:'supermarket' };
      if(name.match(/\b(shop|store|supermarket|shopping|centre|center|mall)\b/)) {
        if(name.includes('mall') || name.includes('centre') || name.includes('center')) return { icon:'üõçÔ∏è', kind:'mall' };
        if(name.includes('market')) return { icon:'üß∫', kind:'market' };
        return { icon:'üõí', kind:'supermarket' };
      }
      return { icon:'üß∫', kind:'market' };
    }

    function buildSuggestionElement(feat, placeOrUser){
      const li = document.createElement('div');
      li.className = 'suggestion-row';
      const meta = feat.properties || {};
      const classified = classifyGeoapifyFeature(feat);
      const iconSpan = document.createElement('div');
      iconSpan.className = 'suggestion-icon';
      iconSpan.textContent = classified.icon;
      const main = document.createElement('div');
      main.style.flex = '1';
      const title = document.createElement('div');
      title.className = 'suggestion-main';
      title.textContent = meta.name || meta.formatted || feat.properties.formatted || 'Unknown';
      const sub = document.createElement('div');
      sub.className = 'suggestion-sub';
      const address = meta.formatted || ((meta.address) ? Object.values(meta.address).join(', ') : '');
      const categoryLabel = (classified.kind || '').replace('_',' ');
      sub.textContent = (address ? `${address} ‚Äî ${categoryLabel}` : `${categoryLabel}`);
      main.appendChild(title);
      main.appendChild(sub);
      li.appendChild(iconSpan);
      li.appendChild(main);
      return { element: li, classified };
    }

    function attachGeoapifyAutocomplete(inputEl, sugEl, isPlaceSearch=false){
      let timer = null;
      inputEl.addEventListener('input', () => {
        const q = inputEl.value.trim();
        clearTimeout(timer);
        if(!q){ sugEl.style.display = 'none'; sugEl.innerHTML=''; return; }
        timer = setTimeout(async () => {
          const features = await geoapifyAutocomplete(q, AUTOCOMPLETE_LIMIT);
          let filtered = features;
          if(isPlaceSearch){
            filtered = features.filter(f => {
              const cls = classifyGeoapifyFeature(f);
              return ['market','mall','supermarket'].includes(cls.kind);
            });
            if(filtered.length === 0) filtered = features.slice(0,3);
          }
          sugEl.innerHTML = '';
          if(filtered.length === 0){ sugEl.style.display = 'none'; return; }
          filtered.forEach(f => {
            const { element, classified } = buildSuggestionElement(f, isPlaceSearch ? 'place':'user');
            element.addEventListener('click', () => {
              sugEl.style.display = 'none';
              inputEl.value = f.properties.name || f.properties.formatted || '';
              if(isPlaceSearch){
                const lat = f.properties.lat;
                const lon = f.properties.lon;
                const tmpIcon = (classified.kind === 'mall') ? mallEmojiIcon : (classified.kind === 'supermarket' ? shopEmojiIcon : marketEmojiIcon);
                const tmp = L.marker([lat, lon], { icon: tmpIcon }).addTo(map);
                tmp.bindPopup(`<strong>${escapeHtml(inputEl.value)}</strong><div style="margin-top:8px;"><button class="nav-btn" id="navTmpBtn">Navigate Here</button></div>`).openPopup();
                map.setView([lat, lon], 16);
                setTimeout(() => {
                  const navTmp = document.getElementById('navTmpBtn');
                  if(navTmp) {
                    navTmp.addEventListener('click', () => {
                      setElementLoading(navTmp, true);
                      const target = { lat: lat, lng: lon, title: inputEl.value };
                      window._ml_state.currentRouteTarget = target;
                      dropRedMarketPin(lat, lon, inputEl.value);
                      drawRouteTo(target, navTmp).finally(()=> setElementLoading(navTmp, false));
                      map.closePopup();
                    });
                  }
                }, 150);
                setTimeout(()=>{ try{ map.removeLayer(tmp); }catch(e){} }, 12000);
              } else {
                const lat = f.properties.lat;
                const lon = f.properties.lon;
                userLatLng = { lat, lng: lon };
                window._ml_state.userLatLng = userLatLng;
                userMarker.setLatLng([lat, lon]);
                map.setView([lat, lon], 16);
                updateStatus(`User location set to: ${inputEl.value}`);
                inputEl.style.boxShadow = "0 0 0 3px rgba(25,118,210,0.12)";
                if(window._ml_state.currentRouteTarget) drawRouteTo(window._ml_state.currentRouteTarget);
                sugEl.style.display = 'none';
              }
            });
            sugEl.appendChild(element);
          });
          sugEl.style.display = 'block';
        }, 180);
      });

      // hide suggestions on outside click
      document.addEventListener('click', (ev) => {
        if(!inputEl.contains(ev.target) && !sugEl.contains(ev.target)) sugEl.style.display = 'none';
      });
    }

    attachGeoapifyAutocomplete(document.getElementById('userSearch'), document.getElementById('userSug'), false);
    attachGeoapifyAutocomplete(document.getElementById('placeSearch'), document.getElementById('placeSug'), true);
        // ----------------- ROUTING (Geoapify) -----------------
    async function drawRouteTo(target, callerBtn = null){
      if(!target || !window._ml_state.userLatLng) {
        updateStatus('No target or user location.');
        return;
      }
      updateStatus('Calculating route...');
      if(window._ml_state.routeLayer){ try{ map.removeLayer(window._ml_state.routeLayer); }catch(e){} window._ml_state.routeLayer = null; }

      const from = `${window._ml_state.userLatLng.lat},${window._ml_state.userLatLng.lng}`;
      const to = `${target.lat},${target.lng}`;
      const url = `https://api.geoapify.com/v1/routing?waypoints=${encodeURIComponent(from)}|${encodeURIComponent(to)}&mode=drive&format=geojson&apiKey=${API_KEY_GEOAPIFY}`;

      try{
        const r = await fetch(url);
        if(!r.ok) throw new Error('Routing failed: ' + r.status);
        const j = await r.json();
        const feat = (j.features && j.features[0]) ? j.features[0] : null;
        if(!feat || !feat.geometry){
          updateStatus('No route returned by Geoapify.');
          return;
        }

        let coords = [];
        if(feat.geometry.type === 'MultiLineString'){
          feat.geometry.coordinates.forEach(arr => arr.forEach(c => coords.push(c)));
        } else if(feat.geometry.type === 'LineString'){
          coords = feat.geometry.coordinates.slice();
        } else {
          updateStatus('Unexpected route geometry.');
          return;
        }
        const latlngs = coords.map(c => [c[1], c[0]]);

        const poly = L.polyline(latlngs, { color:'#00a859', weight:6, opacity:0.95, lineJoin:'round' }).addTo(map);
        window._ml_state.routeLayer = poly;
        map.fitBounds(poly.getBounds(), { padding:[40,40] });

        // calculate distance (try properties)
        let distMeters = null;
        if(feat.properties && typeof feat.properties.distance === 'number') distMeters = feat.properties.distance;
        else if(j.properties && typeof j.properties.distance === 'number') distMeters = j.properties.distance;

        if(distMeters == null){
          distMeters = 0;
          for(let i=1;i<latlngs.length;i++){
            distMeters += haversineKm(latlngs[i-1][0], latlngs[i-1][1], latlngs[i][0], latlngs[i][1]) * 1000;
          }
        }
        const distKm = distMeters / 1000;
        updateStatus(`Route drawn ‚Äî ${distKm.toFixed(2)} km`);
        const popupDistanceEl = document.getElementById('popupDistance');
        if(popupDistanceEl) popupDistanceEl.textContent = `${distKm.toFixed(2)} km`;
      }catch(err){
        console.error(err);
        updateStatus('Routing error ‚Äî try again.');
      }
    }

    function dropRedMarketPin(lat, lng, title){
      if(window._ml_state.dropMarketMarker){ try{ map.removeLayer(window._ml_state.dropMarketMarker); }catch(e){} window._ml_state.dropMarketMarker=null; }
      window._ml_state.dropMarketMarker = L.marker([lat, lng], { icon: marketRedIcon }).addTo(map).bindPopup(`<strong>${escapeHtml(title || 'Market')}</strong>`).openPopup();
      const placeInput = document.getElementById('placeSearch');
      if(placeInput) placeInput.style.boxShadow = "0 0 0 3px rgba(211,47,47,0.12)";
      window._ml_state.currentRouteTarget = { lat, lng, title };
      autoZoomBoth();
    }

    document.getElementById('clearRouteBtn').addEventListener('click', () => {
      if(window._ml_state.routeLayer){ try{ map.removeLayer(window._ml_state.routeLayer); }catch(e){} window._ml_state.routeLayer = null; updateStatus('Route cleared'); }
      if(window._ml_state.dropMarketMarker){ try{ map.removeLayer(window._ml_state.dropMarketMarker); }catch(e){} window._ml_state.dropMarketMarker=null; }
      window._ml_state.currentRouteTarget = null;
    });

    // ----------------- AUTO-TRACK USER MOVEMENT -----------------
    let geoWatchId = null;
    function startWatchPosition(){
      if(!navigator.geolocation) { updateStatus('Geolocation unavailable'); return; }
      try{
        geoWatchId = navigator.geolocation.watchPosition(pos => {
          const lat = pos.coords.latitude;
          const lng = pos.coords.longitude;
          const d = haversineKm(window._ml_state.userLatLng.lat, window._ml_state.userLatLng.lng, lat, lng) * 1000;
          window._ml_state.userLatLng = { lat, lng };
          userMarker.setLatLng([lat, lng]);
          if(window._ml_state.currentRouteTarget && d > 20) drawRouteTo(window._ml_state.currentRouteTarget);
          updateStatus(`You: ${lat.toFixed(5)}, ${lng.toFixed(5)}`);
        }, err => {
          console.warn('watchPosition error', err);
          updateStatus('Unable to watch position: ' + (err.message || 'error'));
        }, { enableHighAccuracy:true, maximumAge:2000, timeout:8000 });
      }catch(e){
        console.warn('startWatchPosition failed', e);
      }
    }
        // Detect button with spinner
    document.getElementById('locateBtn').addEventListener('click', () => {
      const btn = document.getElementById('locateBtn');
      setButtonLoading(btn, true);
      if(!navigator.geolocation){ alert('Geolocation not supported'); setButtonLoading(btn, false); return; }
      updateStatus('Detecting location...');
      navigator.geolocation.getCurrentPosition(pos => {
        const lat = pos.coords.latitude;
        const lng = pos.coords.longitude;
        window._ml_state.userLatLng = { lat, lng };
        userMarker.setLatLng([lat, lng]);
        map.setView([lat, lng], 16);
        updateStatus(`Detected: ${lat.toFixed(5)}, ${lng.toFixed(5)}`);
        const userInput = document.getElementById('userSearch');
        if(userInput) userInput.style.boxShadow = "0 0 0 3px rgba(25,118,210,0.12)";
        if(geoWatchId === null) startWatchPosition();
        setButtonLoading(btn, false);
      }, err => {
        console.warn(err);
        alert('Unable to detect location: ' + (err.message || 'error') + '. Use the search box to correct position.');
        updateStatus('Detection failed; please search or drag the pin.');
        setButtonLoading(btn, false);
      }, { enableHighAccuracy:true, timeout:8000, maximumAge:60000 });
    });

    // Permission pre-check
    if(navigator.permissions){
      try{
        navigator.permissions.query({ name:'geolocation' }).then(p => {
          if(p.state === 'granted') startWatchPosition();
        }).catch(()=>{ /* ignore */ });
      }catch(e){ /* ignore */ }
    }

    // ----------------- UTILS -----------------
    function haversineKm(aLat,aLng,bLat,bLng){
      const R=6371;
      const dLat=(bLat-aLat)*Math.PI/180;
      const dLng=(bLng-aLng)*Math.PI/180;
      const A = Math.sin(dLat/2)*Math.sin(dLat/2) + Math.cos(aLat*Math.PI/180)*Math.cos(bLat*Math.PI/180)*Math.sin(dLng/2)*Math.sin(dLng/2);
      const C = 2*Math.atan2(Math.sqrt(A), Math.sqrt(1-A));
      return R*C;
    }
    async function reverseGeocode(lat,lng){
      // Use Geoapify reverse geocode for better labels (falls back to empty)
      try {
        const url = `https://api.geoapify.com/v1/geocode/reverse?lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lng)}&apiKey=${API_KEY_GEOAPIFY}`;
        const r = await fetch(url);
        if(!r.ok) return "";
        const j = await r.json();
        if(j && j.features && j.features[0] && j.features[0].properties) return j.features[0].properties.formatted || "";
      } catch(e){
        console.warn('reverseGeocode failed', e);
      }
      return "";
    }
    function escapeHtml(s){ return String(s).replace(/[&<>"']/g, function(m){ return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]); }); }

    function autoZoomBoth(){
      try{
        if(window._ml_state.userLatLng && window._ml_state.currentRouteTarget){
          const u = L.latLng(window._ml_state.userLatLng.lat, window._ml_state.userLatLng.lng);
          const m = L.latLng(window._ml_state.currentRouteTarget.lat, window._ml_state.currentRouteTarget.lng);
          const grp = L.featureGroup([L.marker(u), L.marker(m)]);
          map.fitBounds(grp.getBounds(), { padding:[40,40] });
        } else if(window._ml_state.userLatLng) {
          map.setView([window._ml_state.userLatLng.lat, window._ml_state.userLatLng.lng], 14);
        }
      }catch(e){ console.warn('autoZoomBoth failed', e); }
    }

    // Button loading helpers
    function setButtonLoading(btn, isLoading){
      if(!btn) return;
      if(isLoading){
        btn.classList.add('loading');
        btn.setAttribute('aria-busy','true');
        btn.disabled = true;
      } else {
        btn.classList.remove('loading');
        btn.removeAttribute('aria-busy');
        btn.disabled = false;
      }
    }
    function setElementLoading(el, isLoading){
      if(!el) return;
      if(isLoading){
        el.dataset.prevText = el.innerHTML;
        el.innerHTML = `<span class="spinner" style="display:inline-block;width:14px;height:14px;border:2px solid rgba(255,255,255,0.35);border-top-color:#fff;border-radius:50%;animation:spin .7s linear infinite;margin-right:6px;"></span>${el.textContent || '‚Ä¶'}`;
        el.disabled = true;
      } else {
        if(el.dataset.prevText) el.innerHTML = el.dataset.prevText;
        el.disabled = false;
      }
    }

    // mirror initial userLatLng into global
    window._ml_state.userLatLng = { lat: userLatLng.lat, lng: userLatLng.lng };

    map.setView(ACCRA, INITIAL_ZOOM);
    updateStatus('Map ready ‚Äî press "Load Nearby Places" to populate markets & malls.');

    // debugging shortcuts
    window._fetchPlacesAndShow = fetchPlacesAndShow;
    window._drawRouteTo = drawRouteTo;

    // End IIFE
  })();
  </script>

  <!-- Save button area -->
<div class="topbar" style="top:auto;bottom:12px;justify-content:center;">
  <button class="btn" id="saveLocationBtn">Save Location</button>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const saveBtn = document.getElementById('saveLocationBtn');

  // Helper: calculate distance in km
  function haversineKm(lat1, lon1, lat2, lon2) {
    const R = 6371; // Earth radius in km
    const toRad = deg => deg * Math.PI / 180;
    const dLat = toRad(lat2 - lat1);
    const dLon = toRad(lon2 - lon1);
    const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2)**2;
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }

  // Helper: optional loading state
  function setButtonLoading(btn, loading) {
    if (loading) {
      btn.disabled = true;
      btn.textContent = 'Saving...';
    } else {
      btn.disabled = false;
      btn.textContent = 'Save Location';
    }
  }

  // Main save logic
  saveBtn.addEventListener('click', async () => {
    try {
      setButtonLoading(saveBtn, true);

      const state = window._ml_state || {};
      const user = state.userLatLng;
      let target = null;

      // Prefer route target, then dropped marker
      if (state.currentRouteTarget && state.currentRouteTarget.lat) {
        target = {
          lat: state.currentRouteTarget.lat,
          lng: state.currentRouteTarget.lng,
          title: state.currentRouteTarget.title || ''
        };
      } else if (state.dropMarketMarker && typeof state.dropMarketMarker.getLatLng === 'function') {
        const p = state.dropMarketMarker.getLatLng();
        target = {
          lat: p.lat,
          lng: p.lng,
          title: state.dropMarketMarker.__title || ''
        };
      }

      if (!user || !target) {
        alert('Please select your location and a market before saving.');
        setButtonLoading(saveBtn, false);
        return;
      }

      // Reverse geocode safely (optional)
      let userLabel = document.getElementById('userSearch')?.value || '';
      let marketLabel = document.getElementById('placeSearch')?.value || target.title || '';
      if (typeof reverseGeocode === 'function') {
        try { 
          const u = await reverseGeocode(user.lat, user.lng);
          if (u) userLabel = u;
        } catch(e) { console.warn('User reverse geocode failed', e); }

        try { 
          const m = await reverseGeocode(target.lat, target.lng);
          if (m) marketLabel = m;
        } catch(e) { console.warn('Market reverse geocode failed', e); }
      }

      // Calculate distance
      const distKm = haversineKm(user.lat, user.lng, target.lat, target.lng);

      // Save all info to localStorage
      const payload = {
        userLat: user.lat,
        userLng: user.lng,
        userLabel: userLabel,
        marketLat: target.lat,
        marketLng: target.lng,
        marketLabel: marketLabel,
        distanceKm: distKm.toFixed(2),
        savedAt: Date.now()
      };
      localStorage.setItem('ml_saved_location', JSON.stringify(payload));

      // Redirect after short delay
      setTimeout(() => {
        setButtonLoading(saveBtn, false);
        window.location.href = 'index.html';
      }, 300);

    } catch(err) {
      console.error(err);
      alert('Failed to save location. Please try again.');
      setButtonLoading(saveBtn, false);
    }
  });
});
</script>

</body>
</html>